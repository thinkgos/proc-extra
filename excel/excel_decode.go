package excel

import (
	"errors"
	"reflect"

	"github.com/spf13/cast"
)

// Decode 反射出工作表到数据
// T 支持两种类型格式
//   - T为结构体切片
//   - T为[]string
func (e *File[T]) Decode(sheet string, opts ...Option) ([]T, error) {
	c := Config{}
	c.takeOptions(opts...)

	reflectValue := reflect.ValueOf([]T{})
	dataElemType := reflectValue.Type().Elem()
	isPtr := dataElemType.Kind() == reflect.Ptr
	if isPtr {
		dataElemType = dataElemType.Elem()
	}
	if dataElemType.Kind() != reflect.Struct &&
		(dataElemType.Kind() != reflect.Slice || dataElemType.Elem().Kind() != reflect.String) {
		return nil, errors.New("xlsx: slice element not a struct or []string")
	}

	// 获取工作表
	index, err := e.GetSheetIndex(sheet)
	if err != nil {
		return nil, err
	}
	if index < 0 {
		return nil, errors.New("xlsx: not found active sheet")
	}
	e.SetActiveSheet(index)

	// 数据起始行
	rowStart := c.rowStart
	if c.enableHeader {
		rowStart += 1 // skip header
	}

	rows, err := e.Rows(sheet)
	if err != nil {
		return nil, err
	}
	defer rows.Close() // nolint: errcheck
	for totalRows := 1; rows.Next(); totalRows++ {
		if totalRows < rowStart {
			continue
		}
		// 如果有限制, 则超出行数则跳过
		if c.readMaxLines > 0 && totalRows >= (c.readMaxLines+rowStart) {
			break
		}
		line, err := rows.Columns()
		if err != nil {
			return nil, err
		}

		if dataElemType.Kind() == reflect.Struct {
			elem := reflect.New(dataElemType)
			// scan to struct
			elem, err = scanIntoStruct(elem, line)
			if err != nil {
				return nil, err
			}
			if isPtr {
				elem = elem.Addr()
			}
			reflectValue = reflect.Append(reflectValue, elem)
		} else {
			reflectValue = reflect.Append(reflectValue, reflect.ValueOf(line))
		}
	}
	return reflectValue.Interface().([]T), nil
}

func scanIntoStruct(values reflect.Value, line []string) (reflect.Value, error) {
	vv := values
	for vv.Kind() == reflect.Ptr {
		vv = vv.Elem()
	}
	for colIdx, idx, t := 1, 0, vv.Type(); idx < t.NumField(); idx++ {
		field := t.Field(idx)
		if !field.IsExported() {
			continue
		}
		tag := field.Tag.Get("xlsx")
		if tag == "-" {
			continue
		}
		index := colIdx - 1
		colIdx += 1
		if index >= len(line) {
			continue
		}
		fieldValue := vv.Field(idx)
		val := line[index]
		switch field.Type.Kind() { // nolint: exhaustive
		case reflect.String:
			fieldValue.SetString(val)
		case reflect.Bool:
			fieldValue.SetBool(cast.ToBool(val))
		case reflect.Int,
			reflect.Int8,
			reflect.Int16,
			reflect.Int32,
			reflect.Int64:
			fieldValue.SetInt(cast.ToInt64(val))
		case reflect.Uint,
			reflect.Uint8,
			reflect.Uint16,
			reflect.Uint32,
			reflect.Uint64:
			fieldValue.SetUint(cast.ToUint64(val))
		case reflect.Float32,
			reflect.Float64:
			fieldValue.SetFloat(cast.ToFloat64(val))
		default:
			continue
		}
	}
	return vv, nil
}
